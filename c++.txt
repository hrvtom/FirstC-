>>>>>
ANSI/ISO C++ specifikacija jezika nudi predefinirane globalne simbole __LINE__ i __FILE__ (dvostruki znak podcrtavanja se nalazi ispred
i iza rijeci). Simbol __LINE__ ima numericku vrijednost i pokazuje broj linije u kojoj je simbol naveden, dok simbol __FILE__
ima vrijednost znakovnog niza i daje naziv datoteke u kojoj je linija navedena.

>>>>>
variable definition
	int    i, j, k;
	char   c, ch;

For definition without an initializer: variables with static storage duration are implicitly initialized with NULL
(all bytes have the value 0); the initial value of all other variables is undefined.

variable initialization
	byte z = 22;                // definition and initializes z. 
	byte b;                     // definition b
	b = 33;                     // initialization b
	char x = 'x';               // the variable x has the value 'x'.
	float x(1.875f);

When a local variable is defined, it is not initialized by the system, you must initialize it yourself.
The initial value for any local variables not explicitly initialized will have an undefined initial value.
Global variables not explicitly initialized are initialized automatically by the system when you define them as follows:
	int     0
	char    '\0'
	float   0
	double  0
	pointer NULL

In next case Vektor is an object, and defining Vektor the following way actually executes no argument constructor. 
	Vektor someVektor;
If it was written like Vekotr someVektor(); this will be handedled by compiler as no argument function definition returnnig
Vektor as a result.
Defining and initializing Vektor with some data with constructor can be done like:
	Vektor someVekotr(constructorParameterHere);

Declaring objects can be done this way too, both pointer and reference are defined here:
	Vektor *pointerToVektor, &referenceToVektor = someVektor;
	
	
>>>>>
Constant creation
The "const" keyword is used to create a "read only" variable. It defines constant that cannot be modified and must be
initialized during its definition.

	const double pi = 3.1415947;
The value of pi cannot be modified by the program. 

	#define Score 5000
The constant does not have a type such as int or char.
The #define directive enables a simple text substitution that replaces every instance of Score in the code with 5000.

Constants are r-values but cannot be l-values. 

>>>>>
macro creation
makro funkcije se prevode tako da se poziv jednostavno zamijeni tekstom definicije makro funkcije, pri cemu se formalni parametri
zamijene stvarnima.

    #define min(a,b)  ((a) < (b) ? (a) : (b))
    
    j = manji(++i,10) se prevede kao
    
    j = ((++i) < (10) ? (++i) : 10);
                        uuups
                        
>>>>>
if statement

In C++, the value 0 also is considered false and any other value is true. 
	if (!x) 
	if (x == 0) 
Both statements are true when x equals 0. The second statement is somewhat easier to comprehend. 

You can define and initialize a variable within an if statement.
The expression is true if converting the variable's value to a bool type yields true.
The variable is available within the if statement.
	if( int x = func() ) 
	{ 
	. . . // Here to work with x. 
	}           
The return value of the function, func(), is used to initialize the variable x.
If this value is not 0, the statements in the next block are executed.
The variable x no longer exists after leaving the if statement. 

>>>>>
switch statement

The switch statement compares the value of one expression with multiple constants.
	switch( expression ) 
	{ 
		case const1: [ statement ] 
							[ break; ] 
		case const2: [ statement ] 
							[ break; ] 
		. 
		. 
		. 
		[default:  statement ] 
	} 
First, the expression in the switch statement is evaluated.
It must be an integral type.
The result is then compared to the constants, const1, const2, ..., in the case labels.
The constants must be different and can only be integral types including boolean values and character constants. 

>>>>>
for loop statement
	for (int x = 0, y = 0; x < 10; x++, y++) 
	{ 
		std::cout << x * y << "\n"; 
	}

	for( expression1; expression2; expression3 ) 
      statement 
		expression1 is executed first and only once to initialize the loop.
		expression2 is the controlling expression, which is always evaluated prior to executing the loop body
		if expression2 is false, the loop is terminated
		if expression2 is true, the loop body is executed. Subsequently, the loop is reinitialized by executing
			expression3 and expression2 is re-tested. 
Any of the three expressions in a for statement can be omitted.
You must type at least two semicolons. The shortest loop header is therefore:
	for(;;) 

>>>>>
for each

The foreach has two sections separated by a colon : instead of three separated by semicolons.
The first section is a variable that will hold an element of the array. The second is the name of the array. 
	int production[] = { 1, 6, 8, 4, 3 };
	for (int year : production)
	{
		std::cout << "Output: " << year << std::endl;
	}
	
>>>>>
Declaration,definition,initialization

A variable declaration is useful when you are using multiple files and you define your variable in one of the files
which will be available at the time of linking of the program. You will use "extern" keyword to declare a variable at
any place. Though you can declare a variable multiple times in your C++ program, but it can be defined only once in
a file, a function or a block of code.

Deklaracijom funkcije, odnosno klase, stvara se samo prototip, koji se konkretizira tek navodenjem definicije. Iako je svaka definicija
ujedno i deklaracija, pod deklaracijom u uzem smislu podrazumijevamo samo navodenje prototipa.
Deklaracije se smiju ponavljati, ali se one moraju podudarati po tipu (izuzetak su preoptereæene funkcije i operatori). Naprotiv,
definicija smije biti samo jedna

extern int d = 3, f = 5;    // declaration of d and f.  ???????
int d = 3, f = 5;           // definition and initializing d and f. 
byte z = 22;                // definition and initializes z. 
char x = 'x';               // the variable x has the value 'x'.

s1.cpp
extern const float pi = 3.1415926; // definicija // da li je ovdje potreban extern ???? // Prevoditelj ce zbog operatora pridruivanja
																							jednostavno zanemariti kljucnu rijec "extern".
s2.cpp
// samo deklaracija – definicija je negdje drugdje:
extern const float pi;
Umetanjem kljucne rijeci "extern" ispred deklaracije prevoditelju se daje na znanje da je taj objekt (misli se bilo na objekt neke klase,
varijablu ili funkciju) definiran u drugom modulu.
j.cpp
	int bwv = 565;
	int toccata() { // definicija funkcije
		//...
	}
b.cpp
	extern int bwv; // samo deklaracija
	extern int toccata(); // također
	float fuga() { // deklaracija & definicija
		//...
	}
>>>>>
Operator  - Address Operator

You can use the address-of operator & to get variable memory address. 

>>>>>
Array

	int my_array[10] = { 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 };
	int my_array[] = { 10, 20, 30, 40, 50 }; 
	const int size = sizeof(my_array) / sizeof(my_array[0]);
	
>>>>>
Fuctions without arguments

If a function does not expect an argument, the function prototype must be declared as void or empty braces. 
	int rand( void );
	or
	int rand(); 

>>>>>
Prototype

The prototype is the declaration of the function and describes only the formal interface of that function.
You can omit parameter names from the prototype. 

>>>>>
Default Function Parameters

If the function prototype declares a default value for a parameter, the function can be called without that parameter. 
If a parameter does not have a default value, no previous parameter may have a default value. 

	permitted
	long my_function(int x, int y, int z = 1, int t = 2000); 
	not permitted
	long my_function(int x, int y, int z = 1, int t);
	
Uocimo kako su podrazumijevani argumenti konstruktora navedeni samo u deklaraciji klase, ali ne i u definiciji konstruktora.

>>>>>
auto-typed variables
The "auto" keyword makes C++ to infer type based on the value initially assigned to it. 
	auto index = 3; 
	auto multiple = 2.25F; 
same as:
	int index = 3; 
	float multiple = 2.25F; 
multiple value assignement
	auto a = 86, b = 75, c = 309; 

>>>>>
Auto-Typed return values

To make a function's return type determined by deduction, use "auto" where the return type is specified,
as in this simple function:
	auto subtract(int x, int y) 
	{ 
		return x - y; 
	} 

>>>>>
Function overloading/Overriding

When you overload a member function, you create more than one function with the same name but with different signatures. 
When you override a member function, you create a function in a derived class with the same name
as a function in the base class and with the same signature. 

In C++, more than one function can have the same name as long as there are differences in their arguments.
The functions must have different data types for parameters, a different number of parameters, or both.
The return types for overloaded functions do not factor into whether they are different.
You can't overload function by making the return different, however.

>>>>>
Function Inline

If a C++ function is declared with the keyword "inline", the compiler copies the code from the inline function directly into
the place where the function was called.
The inline keyword is used in the function prototype:
	inline int double(int); 
The function itself does not change:
	int double(int target) 
	{ 
		return 2 * target; 
	} 
Only used for some simple functions

You can make member functions inline. The keyword inline appears before the return value, as in this example:
	inline int Cart::getSpeed() 
	{ 
		return speed; 
	} 
You can put the definition of a function in the declaration of the class, which automatically makes that function inline.
Here's an example:
	class Cart 
	{ 
	public: 
		int getSpeed() const { return speed; } 
		void setSpeed(int newSpeed); 
	}; 

>>>>>
A function that sets or gets the value of a private member variable is called an accessor.
Other classes must call the accessor instead of working directly with the variable. 

>>>>>
Function Lambda expressions

A lambda expressions create inline anonymous functions. 
	auto my_lambda = [](){ std::cout << "this is a test!" << std::endl; }; 
	my_lambda();
When a lambda expression has no arguments, the parentheses can be left out of the expression.
	auto my_lambda = []{ std::cout << "this is a test!" << std::endl; };
The lambda expression can have one or more arguments, which are specified within the parenthesis marks after the
[ ] square brackets.
	auto multiply = [](int x, int y){ std::cout << "Total: " << x * y << std::endl; }; 
	multiply(5, 5);
The expression can return a value by specifying its return type (or auto) after a "->" operator. 
	auto multiply = [](int x, int y) -> int { return x * y; }; 
	int sum = multiply(7, 17);
To reference the outside variables use [ ] square brackets, which are called the capture block.
List the variables inside the [ and ] brackets separated by commas.
	int x = 7; 
	auto multiply = [x](int y) -> int { return x * y; }; 
	int sum = multiply(17); 
	
>>>>>
Class Declaratin vs Class Definitions
Declaration (usuali in .h or .hpp file)
	class Cart 
	{ 
	public: 
		int speed; 
		int wheelSize;
		ing getSpeed();
		pedal(); 
		brake(); 
	}; 
Because a header file might potentially be included by multiple files, it cannot contain definitions that might produce
multiple definitions of the same name. The following are not allowed, or are considered very bad practice:
    built-in type definitions at namespace or global scope
    non-inline function definitions
    non-const variable definitions
    aggregate definitions
    unnamed namespaces
    using directives
Use of the 'using' directive will not necessarily cause an error, but can potentially cause a problem because it brings the namespace
into scope in every .cpp file that directly or indirectly includes that header.
Sample header file
// sample.h
#pragma once
#include <vector> // #include directive
#include <string>

namespace N  // namespace declaration
{
    inline namespace P
    {
        //...
    }

    enum class colors : short { red, blue, purple, azure };

    const double PI = 3.14;  // const and constexpr definitions
    constexpr int MeaningOfLife{ 42 };
    constexpr int get_meaning()
    {
        static_assert(MeaningOfLife == 42, "unexpected!"); // static_assert
        return MeaningOfLife;
    }
    using vstr = std::vector<int>;  // type alias
    extern double d; // extern variable

#define LOG   // macro definition

#ifdef LOG   // conditional compilation directive
    void print_to_log();
#endif

    class my_class   // regular class definition,
    {                // but no non-inline function definitions

        friend class other_class;
    public:
        void do_something();   // definition in my_class.cpp
        inline void put_value(int i) { vals.push_back(i); } // inline OK

    private:
        vstr vals;
        int i;
    };

    struct RGB
    {
        short r{ 0 };  // member initialization
        short g{ 0 };
        short b{ 0 };
    };

    template <typename T>  // template definition
    class value_store
    {
    public:
        value_store<T>() = default;
        void write_value(T val)
        {
            //... function definition OK in template
        }
    private:
        std::vector<T> vals;
    };

    template <typename T>  // template declaration
    class value_widget;
}
Remember that if you are doing template programming, then you have to keep everything in the .h file so that the compiler will
instantiate the right code at the moment of compilation.

Definition (Usually in .cpp file) defining declared constructors and methods.
	int Cart::getSpeed() 
	{ 
		return speed; 
	}

>>>>>
"const"

    const int Constant1=96; 
will create an integer constant, unimaginatively called "Constaint1"
It also works with pointers but one has to be careful where "const" is put as that determines whether the pointer or
what it points to is constant. For example,
    const int * Constant2 
declares that Constant2 is a variable pointer to a constant integer and
    int const * Constant2
is an alternative syntax which does the same,
If you declare a pointer to a const object, the only functions that you can call with that pointer are const functions.
When you declare an object to be const, you are declaring that the "this" pointer is a pointer to a const object.
    int * const Constant3
declares that Constant3 is constant pointer to a variable integer and
    int const * const Constant4
declares that Constant4 is constant pointer to a constant integer. Basically "const" applies to whatever is on its immediate left
(other than if there is nothing there in which case it applies to whatever is its immediate right).

Even more useful is a pointer (constant or otherwise) to a const value. This is useful for returning constant strings
and arrays from functions which, because they are implemented as pointers, the program could otherwise try to alter and crash.
Instead of a difficult to track down crash, the attempt to alter unalterable values will be detected during compilation.
(this is valid because of some C shit and how C retrnes strings and arrays)
    char *Function1()
    { return "Some text";}
then the program could crash if it accidentally tried to alter the value doing
    Function1()[1]="a";
whereas the compiler would have spotted the error if the original function had been written
    const char *Function1()
    { return "Some text";}

	void myfunc( const char x );
	void myfunc( const char *x );
A pointer that is defined as const in the parameter declarations, the function code will not modify what it points to.
Basically, you can use the pointer and it pretty much functions as a "read-only". 
	void Subroutine4(big_structure_type const &Parameter1);
will cause the variable to be passed without copying but stop it from then being altered.

	int myfunc() const;
This is illegal unless it's inside a class declaration - const member functions prevent modification of any class member.
The example, on a C++ member function, means that the contents of the object won't be changed by the call,
it basically means the method cannot modify the class instance
(i.e. the state of the instance before and after calling instance.myfunc() will be the same).
	int myclass::myfunc() const
	{
		// do stuff that leaves members unchanged
	}
	
	
>>>>>
Pointers to memeber functions

A function name is a constatnt pointer to the function.
You can declare a pointer variable that points to a function and to invoke the function using that pointer
The declaration of a function pointer always includes the return type and parentheses indication the type of the parameters
	void square(int&, int&);
	void (*pFunc)(int&,int&);
	.
	.
	pFunct = square;
You can declare an array of pointers to the functions
		void (*pFuncArray[amxArray])(int&,int&)
		
pFunc points to a member function of the class Shape, which takes two integers and returns void: 
	void (Shape::*pFunc)(int, int);

	void (Mammal::*pFunc)() const = 0; // pFunc is pointer to no argument function with void return type
	.
	.
	pFunc = &Mammal::speak;  // both "speak" and "move" are no argument functions with "void" return type
	or
	pFunc = &Mammal::move;
	.
	.
	(ptrToMammaObject->*pFunc)()

>>>>>
Pointers to member functions can be stored in an array. 
	typedef void (Dog::*PDF)() const;
	.
	PDF dogFunctions[maxFuncs] = 
           {   &Dog::speak, 
               &Dog::move, 
               &Dog::eat, 
               &Dog::growl, 
               &Dog::whimper, 
               &Dog::rollOver, 
               &Dog::playDead 
        }; 
		.
		pDog = new Dog; 
        (pDog->*dogFunctions[method - 1])(); 

>>>>>
Default Constructors/Destructors
You can set an object up without specifying parameters:
	Cart shoppingCart; 
	Rectangle rect; 
This calls the default constructor of the class, which is a constructor with no parameters.
If you did not declare a constructor for the class, the compiler creates a default constructor for you.
The default constructor the compiler adds takes no action; it is a constructor with no parameters whose body was empty.
You can define it yourself or be provided one as a default from the compiler.
If you define any constructor, the compiler does not provide a default constructor for you.
In that case, if you want a default constructor (with no parameter), you must define it yourself.
Destructors take no parameters and have no return value.
If you did not define a destructor, the compiler provides an empty destructor for you.

Constructors can be overloaded.
You can't overload destructors. 

A member variable can be set during the initialization or by assigning it a value in the body of the constructor.
To assign values in a constructor's initialization, put a colon after the closing parentheses of the constructor's
parameter list.
After the colon, list the name of a member variable followed by a pair of parentheses.
Inside the parentheses, put an expression that initializes the member variable.
If more than one variable is being set in this manner, separate each one with a comma.

	Cart::Cart():speed(5),wheelSize(12) 
	{ 
		// body of constructor 
	} 

example how to use overloaded constructor:

	SomeObject():SomeObject(13){}
	SomeObject(int value){
	  constructor body
	}
>>>>>
Copy Constructor

The copy constructor is called every time a copy of an object is made.
When you pass an object by value, a temporary copy of that object is made.
If the object is a user-defined object, the class's copy constructor is called.
All copy constructors take one parameter: a reference to an object of the same class.

	Cart(const Cart &trike); 

The default copy constructor copies each member variable from the object passed as a parameter to the member variables
of the new object. This is called a shallow copy. 
A shallow copy copies the exact values of one object's member variables into another object.
Pointers in both objects end up pointing to the same memory.
A deep copy copies the values allocated on the heap to newly allocated memory. 

	Cart::Cart(const Cart& rhs) 
	{ 
		speed = new int; 
		*speed = rhs.getSpeed(); 
	} 
>>>>>
Assign built-in type to custom object

The following code creates a conversion operator: a constructor that takes an int and produces a Counter object. 
	class Counter{
	public: 
		Counter(); 
		Counter(int newValue); 
	.
	.
	private:
		int value;
	}

	Counter::Counter(): value(0) 
	{} 
	
	Counter::Counter(int newValue): value(newValue) 
	{} 
	
	int main() { 
		int beta = 5; 
		Counter alpha = beta; 
		return 0; 
	}
	
The constructor is overloaded to take an int. The effect of this constructor is to create a Counter out of an int. 
Given this constructor, the compiler knows to call it when an integer is assigned to a Counter object. 

>>>>>
Namespaces

Elements belonging to a namespace can be referenced directly by name within the namespace.
Identifikatori klasa, funkcija i drugih elemenata C++ jezika se mogu smjestiti u imenike.
Unutar deklaracije imenika moguce je deklarirati, ali i definirati identifikatore.

To reference an element from outside of the namespace, supply the namespace by adding the scope resolution operator ::
before the element name.
	myLib::count = 7;     // Outside of myLib 
This allows you to distinguish between identical names in different namespaces.
You can use the scope resolution operator :: to reference global names declared outside of any namespaces.
To do so, simply omit the name of the namespace.
You can access a global name hidden by an identical name defined in the current namespace using the following.
	::demo();  // Not belonging to any namespace 
namespaces do not need to be defined contiguously.
You can reopen and expand a namespace you defined previously at any point in the program
namespaces can be nested, and you can define a namespace within another namespace. 

	namespace myLib 
	{ 
		int count; 
		double calculate(double, int); 
		// . . . 
	}

You can access to the elements of a namespace via a "using" declaration or "using" directive.
In this case, you do not need to repeatedly quote the namespace.
"using" Declarations
A using declaration makes an identifier from a namespace visible in the current scope.
	using myLib::calculate;    // Declaration 
You can then call the function calculate() from the myLib namespace.
	double erg = calculate( 3.7, 5);

	void UcitajDatoteku() {
		using RadiSDiskom::Citaj;
		char buf[50];
		if (Citaj(buf, 50)) // radi nešto korisno, npr. okopaj vrt
	}

	int i = 0;
	namespace X {
		int j = 9;
		using ::i; // sinonim za globalni i
	}
	namespace Y {
		using X::i; // sinonim za globalni i
		using X::j; // sinonim za j iz imenika X
	}
	int main() {
		using Y::j;
		cout << Y::i << endl; // ispisuje 0
		cout << j << endl; // ispisuje 9
		return 0;
	}
Deklaracija using jest deklaracija: ona ce na mjestu gdje je navedena deklarirati clanove iz odredjenog imenika, i to samo one clanove
koji su u imeniku u tom trenutku.
U deklaraciji using se ne navode tipovi clanova ili povratni tipovi i lista parametara za funkcije. Ako neki naziv pripada preopterecenoj
funkciji, using uvodi sinonime za sve preopterecene funkcije.

Deklaracija using se moze naci i u deklaraciji klase. Pri tome ona moze referencirati samo clan iz osnovne klase koji se tada uvodi
u podrucje izvedene klase.
	class A {
	private:
		int i;
	protected:
		int j;
	public:
		A(int a, int b) : i(a), j(b) {}
	};
	class B {
	public:
		int k;
	};
	class C : public A {
	public:
		using B::k; // pogreška: B nije osnovna klasa od A
		using A::i; // pogreška: i nije dostupan u klasi C
		using A::j; // OK: j će u klasi C imati javni
		// pristup
	};

"using" Directive
The using directive allows you to import all the identifiers in a namespace.
	using namespace myLib; 
	or
	void UcitajDatoteku() {
		using namespace RadiSDiskom;
		Datoteka dat; // poziv klase iz imenika
		char buf[50];
		if (Citaj(buf, 50)) // poziv funkcije iz imenika
		// ...
	}
	or
	using namespace Ispis;
	void f() {
		Ispisi(5); // OK
		Ispisi(Vektor(5., 6.)); // pogreška: član još nije
		// ubačen u imenik
	}
	namespace Ispis {
		void Ispisi(Vektor &);
	}
	int main() {
		Ispisi(Vektor(5., 6.)); // OK: član je sada dio
		// imenika
		return 0;
	}
iako na mjestu direktive using imenik nije sadrzavao funkciju Ispisi(Vektor &), cim je funkcija dodana ona je automatski dostupna
bez ponovnog navodjenja direktive using. To je zato jer direktiva using ne deklarira clanove imenika na mjestu gdje je navedena,
vec samo upucuje prevoditelja da, ako neki identifikator ne moze raspoznati, neka dodatno pretrazi i podrucje navedenog imenika.

Direktiva using moze se navesti i u sklopu deklaracije imenika, cime se svi identifikatori iz jednog imenika ukljucuju u drugi imenik.
Pri tome valja biti oprezan, jer ako dva imenika sadrze clanove istog naziva, clanovi se nece moci jednoznacno razluciti.

This statement allows you to reference the identifiers in the myLib namespace directly.
If myLib contains an additional namespace and a using directive, this namespace is also imported. 

Moguće je definirati alternativno ime za neki imenik,
	namespace RSD = RadiSDiskom;
	
Posebna vrsta imenika je nameless namespace.
	namespace {
		int i;
		class X;
	}
Ovakav imenik ce sadrzavati elemente jedinstvene za datoteku u kojoj je dana ovakva deklaracija. Varijabla "i" i klasa "X" se ponasaju
kao da su globalni identifikatori, no oni nisu vidljivi izvan datoteke u kojoj su deklarirani. Na taj nacin imenik bez naziva omogucava
deklaraciju "statickih" identifikatora vidljivih iskljucivo unutar datoteke gdje su deklarirani. ???
Clanovima imenika bez naziva se pristupa bez eksplicitnog navodjenja imenika:
	int i;
	namespace {
	 int i;
	 int j;
	}
	
	void f() {
	 j = 0; // OK: pristupa se elementu imenika
	 i = 0; // pogreška: nije navedeno je li to
	 // globalni i ili i iz imenika
	 ::i = 0;// OK: globalni i
	}
>>>>>
Storage Classes

The following storage class specifiers can be used
	extern		use extern to reference global variables defined in the another file. In this way we tell the compiler that
				we are using the global variable not a new one. 
	static
	auto
	register 

You can define an object with:
	Scope              	Meaning
	block scope         The object is only available in the code block in which it was defined.
	file scope			The object can be used within a single module. Only the functions within this module can 
						reference the object.
	program scope		The object is available throughout the program. These objects are often referred to as global.

>>>>>
static storage class

The static storage class instructs the compiler to keep a local variable in existence during the life-time of
the program instead of creating and destroying it each time it comes into and goes out of scope. Therefore,
making local variables static allows them to maintain their values between function calls.

The static modifier may also be applied to global variables. When this is done, it causes that variable's scope
to be restricted to the file in which it is declared.

Funkcija PozoviPaIspisi()('kao' globalna funkcija) je staticka, sto znaci da ona nije vidljiva izvan datoteke poglavar.cpp. Pozeljno je da
ime takve funkcije ne "zagaduje" globalno podrucje imena.

In C++, when static is used on a class data member, it causes only one copy of that member to be shared by all
objects of its class.

class Box {
public:
	static int count;
	.
	.
};

int Box::count = 0;

>>>>>
Characters

      void print(char* c) { // ispisule cijeli char field
         cout << "Printing character: " << c << endl;
      }

void printString(char* c, int i) {// ispisuje char filed od +i indexa
	cout << (c + i) << endl;
}


void printCharacter(char* c, int i) { //ispisuje character na +i indexu
	cout << *(c + i) << endl;
}


>>>>>
NULL pointer
It is always a good practice to assign the pointer NULL to a pointer variable in case you do not have exact address
to be assigned. This is done at the time of variable declaration. A pointer that is assigned NULL is called
a null pointer.

this is possible: - only at variable declaration
	int *pAge = nullptr; 
this is possible too:
	itn *pAge = 0
The constant 0 remains valid as a null pointer value, for reasons of backward compatibility. 
this is not possible:
	int *pAge;
		.
		.
	*pAge = nullptr // this is not variable declaration
this is not possible too:
	int *pAge = nullptr; 
	.
	.
	if(*pAge){   //this doesn't work
	}
but this is possible:
	int *pAge;
	.
	.
	pAge = NULL;
	.
	.
	if(pAge){
	}

null in C++
by declaring reference as method argument, you ensure that method can't work with null values
void someMethod(SomeType& someType){
}
by declaring pointer as a method agrument, method can accept null values soo you need to take care of it
void someMethod(SomeType* someType){
}

>>>>>
typedef

Korisnicki tipovi definirani pomocu kljucne rijeci "typedef" su takoder vidljivi samo unutar datoteke u kojoj su definirani.

>>>>>
Pointers vs Arrays

A pointer that points to the beginning of an array can access that array by using either pointer arithmetic
or array-style indexing.

int  var[MAX] = {10, 100, 200};
      *var = i;    // This is a correct syntax
      var++;       // This is incorrect.

It is perfectly acceptable to apply the pointer operator * to var but it is illegal to modify var value.
The reason for this is that var is a constant that points to the beginning of an array and can not
be used as l-value.

*(var + 2) = 500;
Because an array name generates a pointer constant, it can still be used in pointer-style expressions,
as long as it is not modified.

>>>>>
Virtual function

Virtual Function
A virtual function is a member function of base class which can be redefined by derived class. Virtual function is declared and defined
in base class. Base class having virtual function can be instantiated. Classes having virtual functions are not abstract.

Pure virtual functions
      // pure virtual function
      virtual int area() = 0;

The = 0 tells the compiler that the function has no body and above virtual function will be called pure virtual function.
It may be redefined in a derived class to suit the objects of that class.
A pure virtual function is a member function of base class whose only declaration is provided in base class and should be defined
in derived class otherwise derived class also becomes abstract. No definition is given in base class.
C++ can create abstract data types with pure virtual functions.
A pure virtual function is a virtual function that must be overridden in the derived class.
A virtual function is made pure by initializing it with 0, as in the following statement:
	virtual void draw() = 0;
Any class with one or more pure virtual functions is an abstract data type.You cannot instantiate an object of
a abstract class (ADT). Any class that derives from an ADT inherits the pure virtual function, so it must override
every pure virtual function if it wants to instantiate objects. Or the subclass will be an ADT too.

Nije moguce deklarirati objekte apstraktnih klasa. Moguce je, naprotiv, deklarirati pokazivace i reference na te klase.
(???If SomeGraphObject is apstract class
	SomeGraphObject sgo; NO go for abstract class
	SomeGraphObject *psgo;  OK
	SomeGraphObject &rsgo = someObject; OK
)

If supperclass has pure virtual function, and this function is later on defined in superclass, subclass still needs to 
implement pure virtual function, othervise subclass is stil abstract(koja glupost)

Za nevirtualne clanove se kaze da se pozivaju staticki, za razliku od virtualnih poziva koji se odreduju dinamicki,
na osnovu podataka dostupnih prilikom izvodenja. Clanovi sa statickim pozivom osnovne klase mogu biti redeklarirani
kao virtualni u izvedenoj klasi.

Osim konstruktora, sve ostale funkcijske clanove mozemo uciniti i virtualnima.

Funkcijski clan koji je jednom deklariran virtualnim, ne moze se u izvedenoj klasi pretvoriti u clan sa statickim pozivom.

Slucaj u kojem se zaobilazi mehanizam virtualnih poziva je poziv iz konstruktora ili destruktora. Razlog tome je sto poziv
virtualne funkcije u konstruktoru moze rezultirati pristupom jos neinicijaliziranom dijelu objekta, dok poziv virtualne
funkcije u destruktoru moze rezultirati pristupom vec unistenom dijelu objekta.

Poput svih drugih funkcijskih clanova, i destruktor moze biti virtualan. Iako destruktori nemaju zajednicko ime, oni mogu biti virtualni.
Postoji samo jedan desturktor.
Sve klase koje nasljeduju klasu s virtualnim destruktorom takoder ce imati virtualne destruktore te nije to potrebno eksplicitno
specificirati kljucnom rijeci "virtual", ali dobra je praksa i u izvedenim klasama dodati kljucni rijec virtual ispred deklaracije
destruktora.
Destruktori apstraktnih klasa se u pravilu navode kao virtualni. Razlog tome je sto objekt virtualne klase ne moze biti deklariran,
pa niti destruktor sa statickim pozivom za takav objekt nema smisla.
Pure virtual destructors are legal in standard C++ and one of the most important things to remember is that if a class contains
a pure virtual destructor, it must provide a function body for the pure virtual destructor. You may be wondering why a pure virtual
function requires a function body. The reason is because destructors (unlike other functions) are not actually ‘overridden’, rather
they are always called in the reverse order of the class derivation. This means that a derived class’ destructor will be invoked first,
then base class destructor will be called. If the definition of the pure virtual destructor is not provided, then what function body will
be called during object destruction?

>>>>>
Virtualna osnovna klasa

Kako je u C++ moguce da klasa nasljedjuje po dvije i vise klasa, takodjer je moguce da klase koje se nasljedjuju imaju 
zajednicku osnovnu klasu, tj. one same nasljedjuju istu klasu.
To moze biti i dobro i lose ???

Primjer UokvireniText nasljedjuje i Text i Pravokutnik

      GObject             GObject
         |                   |
      Poligon                |
         |                   |
      Pravokutnik          Text
                \          /
               UokvireniText
               
C++ ima operator za odredjivanje podrucja:
      uokvireniText.GObject::PostaviBoju(boja) - prostupa se PostaviBoja metodi(koja vjerojatno nije virtualna)
      definiranoj u GObject.
U ovom slucaju nije jasno na koji GObject se referencira buduci da postoje 2(neka C++ fantazija)
kako to rijesiti, s pomocu virtualne osnovne klase

               GObject
               /     \
          Poligin    |
               |     |
      Pravokutnik   Text
               \     /
            UokvireniText          
            
     class Poligon: public virtual GObject{....
     class Text: public virtual GObject{......

Dostao ovoj gluposti

>>>>>
References
References are usually used for function argument lists and function return values.
Pointers are variables that hold the address of another object.A reference is alias for an object that already exists. 
Defining a reference does not occupy additional memory.
If you ask a reference(& operator) for its address, it returns the address of its target. 

	//You cannot have NULL reference
	//Once a reference is initialized to an object, it cannot be changed to refer
	//to another object. Pointers can be pointed to another object at any time.
	//A reference must be initialized when it is created. Pointers can be
	//initialized at any time
	int a;
	double b;
	int& ra = a;
	double& rb = b;

          pointer                a,ra
          -------                 ---
          |     |---------------->| |
          -------                 ---

inline T const& Max (T const& a, T const& b)  { 
   return a < b ? b:a; 
} 

A reference aliasing a constant object must be a constant itself. It must be defined using the const keyword to avoid modifying
the object by reference. 
	const int& cref = a;
The reference cref is said to be a read-only identifier.
A read-only identifier can be initialized by a constant, in contrast to a normal reference: 
	const double& pi = 3.1415927;

The return type of a function can be a reference type.
The function call then represents an object, and can be used just like an object.
The object referenced by the return value must exist after leaving the function. !!!

(in this case object exists after leaving the function because of "static", this is some c shit)
	string& message()           // Reference! 
	{ 
		static string str ="Today only cold cuts!"; 
		return str; 
	}
	
	message() = "Let's go to the beer garden!"; 
	message() += " Cheers!"; 
	cout << "Length: " << message().length(); 
	
	class Par {
	public:
		Vektor &refPrvi, &refDrugi;
		// nastavak slijedi ...
	};
Ako se koristi operator pridruzivanja za pristup referenci, mijenja se vrijednost referiranog objekta, a ne reference:
	Par p; // ovakva inicijalizacija nije ispravna
	Vektor v(12.0, 3.0);
	p.refPrvi = v; // mijenja se vrijednost referiranog objekta
Reference se obavezno moraju inicijalizirati, te se to mora uciniti u inicijalizacijskoj listi konstruktora.
	class Par {
	public:
		Vektor &refPrvi, &refDrugi;
		Par(Vektor &v1, Vektor &v2) : refPrvi(v1), refDrugi(v2) {}
	};
Obavezno je bilo staviti v1 i v2 kao reference: u suprotnom bi se prilikom poziva konstruktora stvarale privremene kopije stvarnih parametara,
a reference bi se inicijalizirale adresom tih privremenih kopija. Nakon zavrsetka konstruktora kopije bi se unistile, a reference bi pokazivale
na memoriju u kojoj vise nema objekta.
Na slicne probleme nailazimo ako klasa sadrzava konstantne clanove: njih je takoder potrebno inicijalizirati u konstruktoru, a vrijednost im se
kasnije ne moze mijenjat
Konstantni podatkovni clanovi objekta se obavezno moraju inicijalizirati, te se to mora uciniti u inicijalizacijskoj listi konstruktora.
	class Tablica {
	private:
		int *Elementi;
		int BrojElem, Duljina;
		const int maxDuljina;
	public:
		Tablica();
		Tablica(int BrElem, int duljina);
		// ostali Clanovi se ne mijenjaju
	};
Sada se clan maxDuljina obavezno mora inicijalizirati, i to se mora uciniti u inicijalizacijskoj listi konstruktora:
	Tablica::Tablica() : maxDuljina(50),
						Elementi(new int[10]),
						BrojElem(0), Duljina(10) {
	}
	Tablica::Tablica(int BrElem, int duljina) :
						maxDuljina(duljina), Elementi(new int[10]),
						BrojElem(0), Duljina(BrElem) {
	}

>>>>>
accessing members

Structure
To access any member of a structure, we use the member access operator (.)
	structure.member

To access the members of a structure using a pointer to that structure, you must use the -> operator
	structure_pointer->member

Class
A pointer to a C++ class is done exactly the same way as a pointer to a structure and to access members of a pointer to a class
you use the member access operator -> operator, just as you do with pointers to structures. Also as with all pointers,
you must initialize the pointer before using it.

	my_pointer->GetAge();
	or
	(*my_pointer).GetAge();

>>>>>
Constructing

	Rectangle(int a = 0, int b = 0) :Shape(a, b) {}

struct DemoStruct {
	int someInt;
	double someDouble;
	//struct Constructor
	DemoStruct(int i, double d) :
			someInt(i), someDouble(d) {
	}
};

Objekti se ne inicijaliziraju prema redoslijedu navodenja u inicijalizacijskoj listi konstruktora, vec prema slijedu deklaracije u klasi.
Svi objekti-clanovi neke klase ce biti inicijalizirani konstruktorom navedenim u inicijalizacijskoj listi konstruktora doticne klase.
Ako je neki objekt izostavljen iz inicijalizacijske liste, pozvat ce se podrazumijevani(empty/default) konstruktor.
Podatkovni clanovi ugradenih tipova (int, float, char) ne moraju biti navedeni u inicijalizacijskoj listi,
te ce u tom slucaju ostati neinicijalizirani.

Dobro je uociti da prevoditelj, za klase koje imaju kao clanove reference i konstantne objekte, ne moze sam generirati podrazumijevani konstruktor.
Razlog je u tome sto se reference i konstantni clanovi moraju inicijalizirati u inicijalizacijskoj listi konstruktora te im se vrijednost kasnije
ne moze mijenjati. Prevoditelj ne zna kako treba inicijalizirati referencu, odnosno konstantan clan.

Klasa ne mora definirati konstruktor kopije. Ako on nije eksplicitno definiran, prevoditelj ce ga generirati sam, neovisno o tome
postoji li jos koji drugi konstruktor. Taj konstruktor kopije ce pozvati konstruktor kopije za svaki pojedini podatkovni clan.
Za ugradene tipove konstruktor kopije jednostavno dodjeljuje njihovu vrijednost odgovarajucem podatkovnom clanu objekta.
Za podatkovne clanove koji su objekti korisnicki definiranih klasa, koristi se konstruktor kopije definiran za tu klasu.
Konstruktor kopije se takoder koristi za stvaranje privremenih objekata prilikom prosljedivanja objekata u funkciju i njihovog vracanja.
No u slucaju klase Tablica stvari su drukcije. Ta klasa sadrzi pokazivac na memoriju kojemu se vrijednost odreduje prilikom stvaranja objekta.
Ako bi konstruktor kopije jednostavno inicijalizirao sve clanove kopije vrijednostima clanova originala, oba bi objekta pokazivala na isti objekt.
Klase koje sadrze pokazivace na dinamicki alocirane segmente memorije gotovo uvijek iziskuju korisnicki definiran konstruktor kopije.
>>>>>
Operator overloading
When you implement an operator for a class, you are overloading that operator.
The most common way to overload an operator in a class is to use a member function.
The function declaration takes this form:
	returnType operatorsymbol(parameter list) 
	{ 
		// body of overloaded member function 
	} 
The name of the function is operator keyword followed by the operator symbol, such as + or ++.	The "returnType" is 
the function's return type. The parameter list holds zero, one, or two parameters (depending on the operator). 

	class Counter
	{ 
	public: 
		Counter(); 
		.
		.
		const Counter& operator++(); 
		
	private: 
		int value; 
	}; 

	const Counter& Counter::operator++() 
	{ 
		++value; 
		return *this; 
	} 
	
The way to overload prefix and postfix operator is to include a "int" variable to the operator++() member function.
The integer won't be used; it's just a signal that the function defines the postfix operator. The prefix operator changes
a variable's value before returning it in expressions. The postfix operator returns the value before incrementing or
decrementing it. To do this, in an overloaded member function, a temporary object must be created to hold the original value
while the value of the original object is incremented. The temporary object is returned because the postfix operator requires
the original value, not the incremented value.
The temporary object must be returned by value and not by reference. Otherwise, it goes out of scope as soon as the function
returns. 

	const Counter& operator++();   // prefix 
	const Counter operator++(int); // postfix 
	.
	.
	const Counter& Counter::operator++() // prefix 
	{ 
		++value; 
		return *this; 
	} 
 
	const Counter Counter::operator++(int) // postfix 
	{ 
		Counter temp(*this); 
		++value; 
		return temp; 
	} 

operator =
	
	class Cart 
	{ 
	public: 
		Cart();  
		// copy constructor and destructor use default 
		int getSpeed() const { return *speed; } 
		void setSpeed(int newSpeed) { *speed = newSpeed; } 
		Cart operator=(const Cart&); 
   
	private: 
		int *speed; 
	}; 
	
	Cart Cart::operator=(const Cart& rhs) 
	{ 
		if (this == &rhs) 
				return *this; 
		delete speed;  //!!! why this
		speed = new int;  //!!! why this
		*speed = rhs.getSpeed(); 
		return *this; 
	} 

>>>>>
Destructor
Destruktor se automatski poziva u sljedecim situacijama:
	za automatske objekte na kraju bloka u kojem je objekt definiran (kraj bloka je oznacen zatvorenom viticastom zagradom),
	za staticke i globalne objekte nakon izlaska iz funkcije main(),
	za dinamicke objekte prilikom unistenja dinamickog objekta operatorom delete.
Operator delete se moze bez opasnosti primijeniti na pokazivac koji ima vrijednost nula. U tom slucaju se destruktor ne poziva.

>>>>>
Inheritance _constructor

class Mammal
{
public:
	// constructors 
	Mammal();
	Mammal(int age);
	~Mammal();
	.
	.
protected:
	int age;
	int weight;
}

class Dog : public Mammal
{
public:
	// constructors 
	Dog();
	Dog(int age);
	Dog(int age, int weight);
	Dog(int age, int weight, int breed);
	~Dog();
	.
	.
private:
	int breed;
}

Mammal::Mammal() : age(1), weight(5){std::cout << "Mammal constructor ...\n";}
Mammal::Mammal(int age) : age(age), weight(5){}

Dog::Dog() : Mammal(), breed(2){ std::cout << "Dog constructor ...\n"; }
Dog::Dog(int age) : Mammal(age), breed(2){ std::cout << "Dog(int) constructor ...\n"; }
Dog::Dog(int age, int newWeight) : Mammal(age), breed(2)
{
  weight = newWeight;
  std::cout << "Dog(int, int) constructor ...\n";
}

>>>>>
Inheritance - overriden member function

To access the overridden base member function, write the base name, followed by two colons, and then the function name.

	void Dog::move() const 
	{ 
		std::cout << "Dog moves ...\n"; 
		Mammal::move(3); 
	}
	
	int main() 
	{ 
		Mammal bigAnimal; 
		Dog fido; 
		bigAnimal.move(2); 
		fido.Mammal::move(6); 
		return 0; 
	}
	

>>>>>
Template clases
Templates create a general class and use types as parameters to build specific instances of the parameterized type. 
The generic type in the list becomes a parameter to the definition of the class. 
The action of creating an object from a specific type from a template is called instantiation.
The individual classes are called instances of the template.
keyword "template" must come before class declaration:
	template <class T>
	class List;

or before class definition:
	template <class T> // declare the template and the formal parameter 
	class List         // the class being parameterized 
	{ 
	public: 
		List(); 
		// full class declaration here 
	};

The keyword "template" is used at the beginning of every declaration and definition of a template class.
The template's parameters follow the keyword template; they are the items that will change with each instance.
The keyword "class" is followed by the identifier T.
The keyword "class" indicates that this parameter is a type. 

Slicno predloscima funkcije, parametar predloska klase moze biti i izraz.
	template <class T, int someInt>
	class List;
	
Unutar klase se identifikator ElementListe koristi bez parametara, sto je i logicno: parametri su navedeni u template deklaracije ispred
pocetka deklaracije klase. Naprotiv, izvan deklaracije klase, pored identifikatora klase se uvijek moraju navesti parametri.

implementing  functions not implemented in class definition:

		template <class Tip>
		inline ListElement<Tip>::ListElement(const Tip &elem) :
		value(elem), before(NULL), after(NULL) {}

		template <class Tip>
		inline Tip &ListElement<Tip>::getValue() {
		return value;
	}

U posljednjoj verziji C++ jezika moguće je koristiti podrazumijevane vrijednosti parametara.
	template <class Tip = char>
	class NizZnakova;
	
Specijalizacije predlozaka klasa
Poneki funkcijski clanovi predloska klase mogu biti neadekvatni za neke konkretne tipove koji se mogu proslijediti predloku kao parametar.
U tom slucaju moguce je definirati specijalizaciju funkcijskog clana koja ce precizno definirati nacin na koji doticni clan mora biti
obradjen.
Specijalizacija pojedinog funkcijskog clana predloska se definira tako da se iza naziva clana umjesto formalnih navedu stvarni tipovi
na koje se specijalizacija odnosi (na primjer zelimo promijeniti ponasanje konstruktora za char * tip)
	inline ElementListe<char *>::ElementListe(char * const & elem)
	: vrij(new char[strlen(elem) + 1]), prethodni(NULL), sljedeci(NULL) {
		strcpy(vrij, elem);
	}

Ponekad implementacija definirana predloskom nije dovoljno efikasna za neke tipove. Takodjer, moguce je da za neki tip klasa treba dodatak
javnom sucelju kako bi funkcionirala ispravno. Tada mozemo definirati specijalizaciju cijele klase za pojedini tip. (ma zajebi ovo)

Predlosci klasa sa statickim clanovima
Prilikom definiranja predloska klase moguce je navesti staticke clanove. U tom slucaju svaka instanca navedenog predloska ce imati svoj
zasebni skup statickih clanova. Svaki od tih clanova se mora inicijalizirati zasebno.
	template <class T>
	class Lista {
	private:
		ElementListe<T> *glava, *rep;
	public:
		static int brojLista;
	.
	};
Staticki clanovi se u zaglavlju klase samo deklariraju, no inicijalizirati se moraju izvan klase. To se izvodi ovako:
	template <class T>
	int Lista<T>::brojLista = 0;
Moguæe je takodjer definirati specijalizirane inicijalizacije statickih clanova.
	int Lista<float>::brojLista = 5;
specijalizirana inicijalizacija nema izravne veze sa specijalizacijom predloska. Sama klasa ne mora imati specijalizirane clanove,
ali za neki tip mozemo imati specijaliziranu inicijalizaciju i obrnuto.
Prilikom pristupa statickim clanovima klase definirane predloskom potrebno je navesti puno ime klase.

Konstantni izrazi kao parametri predlozaka
Formalni parametar predloska, osim tipa moze biti i konstantni izraz.
	template <int duljina>
	class Spremnik {...}
Parametar duljina mora biti poznat prilikom prevodjenja. To znaci da on mora biti sastavljen od samih konstanti.

	template <int duljina>
	class Spremnik {
	private:
		char podrucje[duljina];
	public:
		enum {kriticna = (int)(0.75 * duljina),
		zadnji = duljina - 1, maksimum = 1000};
	};
	pristup
	cout << Spremnik<20>::kriticna << endl;
	cout << Spremnik<99>::zadnji << endl;

Posljednja verzija C++ jezika podrzava ugnjezdjivanje predlosaka. Moguce je definirati predlozak neke klase unutar klase ili
unutar predloska klase.

Predlosci i nasljedjivanje
class extending template:
	class SkupRijeci : Lista<char *> {
	// ...
	};
template extending class:
	class Kontejner {
	public:
		virtual int BrojElemenata()=0;
		virtual void Prazni()=0;
	};
	template <class Tip>
	class Lista : public Kontejner {
	// ...
	};
template extending template
	template <class Tip>
	class Stog : public Lista<Tip> {
	// ...
	};
	ili
	template <class Tip>
	class Stog : Lista<char> {
	// ...
	};

Template methods

    template <class T, class U>    // formal parameters of the method
    returnValue SomeMethod(T a, U b){...}  // actual template method, returnValue can be of template value as vell
    
    templete <class T>
    T min(T a, T b){
      a < b ? a : b;
    }
    
    or declaration+definition
    
    templete <class T>
    inline T min(T a, T b){
      a < b ? a : b;
    }
    
    or definition only
    
    template <class T>
    static void sort(T *array, int numOfElements);

kljucna rijec "class" specificira da odredjeni parametar predloska predstavlja neki tip. Podrazumijeva se da taj tip ne mora biti
klasa, vec moze biti i ugradjeni tip ili pobrojenje. Uvedena je nova kljucna rijec "typename" koja se moue koristiti umjesto kljucne
rijeci "class". Time se eksplicitnije naznacava da se odredjeni argument predloska zapravo ime tipa, a ne klasa.

	template <typename T> // T oznacava tip
	void funkcija() {   // ove dvije deklaracije imanu razlicito znacenje
		T::A *pok1; //  uzmi clan A iz tipa T i pomnozi ga sa pok1
		typename T::A *pok2; // typename oznacava da T::A predstavlja tip, iz stvarnog tipa T se pristupa tipu A koji se
							 // nalazi u tipu T, a pok2 je pokazivac na taj tip
	}
	Ako je odredjeni tip potrebno cesto spominjati unutar template-a koristiti:
	typedef typename T::A T_od_A;

Remember that if you are doing template programming, then you have to keep everything in the .h file so that the compiler will
instantiate the right code at the moment of compilation.

!!!!!! ovo sa "typename" koristiti s rezervom, ne podrzavaju svi C++ kompajleri !!!!!!!!

Parametar predloska funkcije moze biti i neka konstanta kojom se dodatno upravlja radom funkcije.
	template <class T, int num>
	void ADCUcitajPolje(T *polje) {
		T pomocnoPolje[num];
		// ...
	}

Slicno podrazumijevanim parametrima funkcija, nova verzija C++ standarda omogucava koristenje podrazumijevanih parametara predloska.
	template <class T, class Preciznost = double>
	void Inverz(T[100][100]);
Prilikom koristenja podrazumijevanih parametara predloska ako je lista parametara predloska prazna potrebno je iza naziva funkcije
navesti prazan par znakova <>.


Pri pozivu template funkcije kompajler koristi tipove argumenata da bi odredio koji se predlozak funkcije koristi.
Zbog toga se i svi formalni argumenti predloska obavezno moraju pojaviti u listi parametara funkcije.
	min<int>(5,6) //OK
	min(5,6)// OK too
	
Primjer zbrajanje
	template <class T1, class T2>
	T1 zbroji(T1 a, T2 b){....
	a sto ako zbrajamo iste tipove ili je rezultat tipa T2
	pa jednostavno rjesenje je definiriti i tipove za sve parametre i rezultat
	template <class T1, class T2, class T3>
	T3 zbroji(T1 a,T2 b){....

>>>>>
Static

Staticki podatkovni clanovi se dodatno razlikuju od obicnih clanova po tome sto klasa moze sadrzavati staticki objekt te klase.
U slucaju obicnih clanova, klasa moze sadrzavati samo pokazivace i reference na objekte te klase, na primjer:

	class Obj {
	// ovo je OK jer je Clan staticki:
	static Obj statickiClan;
	// i ovo je OK jer su Clanovi referenca i pokazivac:
	Obj &ref, *pok;
	// ovo nije OK:
	Obj nestatickiClan;
	};

Staticki clanovi mogu biti navedeni kao podrazumijevani parametri funkcijskim clanovima, dok nestaticki clanovi ne mogu, kao u primjeru

	int a;
	
	class Param {
		int a;
		static int b;
		public:
		// ovo je OK jer je Clan staticki:
		void func1(int = b);
		// i ovo je OK jer se odnosi na globalni a:
		void func2(int = ::a);
		// ovo je greška jer se odnosi na nestaticki Clan a:
		void func3(int = a);
	};

Dozvoljeno je koristiti pokazivace na staticke podatkovne i funkcijske clanove, kao u primjeru

	// ...
	int *pok = &Brojeni::Brojac;
	int (*pokNaFunkciju)() = Brojeni::VrijednostBrojaca;


Dodavanjem kljucne rijeci "static" ispred deklaracije objekta, funkcije ili anonimne unije, eksplicitno se pridjeljuje interno povezivanje,
globalne objekte i funkcije cini "privatnima" za pripadnu datoteku.
To omogucava da se u pojedinim modulima definiraju razliciti globalni objekti ili funkcije s jednakim imenima.
s1.cpp
	static int f(int argument) {
		//...
	}
	static float broj;
	static union {
		int br;
		char ch;
	};
s2.cpp
	static void f() {
		//...
	}
	static char broj;
	static union {
		int br;
		char ch;
	};
>>>>>
Scope
::nekaVarijable global scope
::nekaFunkcija() global scope
Klasa::nekaVarijable class scope
Klasa::nekaFunkcija() class scope

Ime u nekom podrucju sakrit ce isto ime u nadredenom podrucju bez obzira sto ta dva imena oznacavaju razlicite entitete.
	int duljina, func1(), func2(int);
	class IgraSkrivaca {
	public:
		void func1(int); // skriva ::func1()
		int func2; // skriva ::func2(int)
		void duljina(int, float); // skriva ::duljina
	};	
	
>>>>>
Implicitna/explicitina pretvorba pokazivaca

Moguca je implicitna pretvorba pokazivaca i referenci izvedene klase u njenu javnu osnovnu klasu
class Izvedena: public Osnovna{
	Linija *pokLinija = new Linija;
	GrafObjekt *pokObjekt = pokLinija; // implicitna pretvorba
	pokObjekt->PostaviBoju(PLAVA);
	
Nije moguca implicitna konverzija iz izvedene klase u privatnu osnovnu klasu.
class Izvedena: private Osnovna{
ovo nije moguce
	Kompleksni *pokKompl = new Kompleksni(4.0, 6.0);
	Vektor *pokVekt = pokKompl; // ne smije biti dozvoljeno!
ali ako je stvarno potrebno, moguca je eksplicinta konverzija
	pokVekt = (Vektor *)pokKompl;
	
Ne postoji standardna konverzija pokazivaca na izvedenu klasu u pokazivac na protected osnovnu klasu, osim u podrucju izvedene klase.
class Izvedena: protected Osnovna
	int main() {
		// pogreška: nema ugrađene konverzije izvan klase
		Osnovna *pok = new Izvedena();
		return 0;
	}
	void Izvedena::Pristupi() {
		// OK: ugrađena konverzija je ispravna unutar klase
		Osnovna *pok = new Izvedena();
	}
Smisao zastiæcnog nasljedivanja je skrivanje javnog sucelja osnovne klase od vanjskog programa. Uz dozvoljenu pretvorbu, javno sucelje bi 
presutno postalo dostupno i vanjskom programu. Drukcije su okolnosti unutar klase: javno sucelje osnovne klase je regularno dostupno i
unutar klase te zbog toga pretvorba ne moze narusiti princip skrivanja informacija.
	
1. Objekt izvedene klase moze se implicitno pretvoriti u objekt javne osnovne klase.
2. Referenca na objekt izvedene klase moze se implicitno pretvoriti u referencu na
	objekt javne osnovne klase.
3. Pokazivac na objekt izvedene klase moze se implicitno pretvoriti u pokazivac na
	objekt javne osnovne klase.
4. Pokazivac na clan izvedene klase moze se implicitno pretvoriti u pokazivac na clan
	javne osnovne klase.

Dodatno, pokazivac na bilo koju klasu moze se implicitno pretvoriti u pokazivac na tip
void *. Pokazivaè na tip void * se moze jedino eksplicitnom dodjelom tipa pretvoriti u
pokazivac na bilo koji drugi tip.

Ako je potrebno pretvoriti pokazivac na objekt osnovne klase u pokazivac na objekt
izvedene klase, potrebno je koristiti eksplicitnu pretvorbu.

>>>>>
Razlika nasljedivanja i preopterecenja

	class Osnovna {
	public:
		void funkcija();
	};
	class Izvedena : public Osnovna {
	public:
		void funkcija(int);
	};
	
	int main() {
		Izvedena obj;
		// pogreska: nasuprot osekivanju da ce donji poziv
		// pozvati Osnovna::funkcija() to ne funkcionira jer
		// clan Izvedena::funkcija(int) skriva istoimeni clan
		// osnovne klase
		obj.funkcija();
		return 0;
	}
Funkcijski clan u izvedenoj klasi prekrit ce istoimeni clan u osnovnoj klasi iako se oni razlikuju po potpisu. Sve funkcije nekog
skupa preopterecenih funkcija moraju biti definirane u istom podrucju. Ako bismo zeljeli zadrzati varijantu clana funkcija()
i u klasi Izvedena, morali bismo ponoviti njegovu definiciju
	class Izvedena : public Osnovna {
	public:
		void funkcija(int);
		void funkcija() { Osnovna::funkcija(); }
	};

Preopterecene funkcije uvijek moraju biti navedene u istom podrucju imena,dok funkcije u naslijedenoj klasi skrivaju istoimene funkcije osnovne
klase. To pravilo podjednako vrijedi i za operatorske funkcije

	class Osnovna {
	public:
		// ...
		int operator==(int i);
	};
	class Izvedena : public Osnovna {
	public:
		// ...
		int operator==(char *niz);
	};
	Izvedena obj;
	if (obj == "ab") cout << "Jednako!" << endl; // OK
	if (obj == 1) cout << "Podjednako!" << endl; // pogreška
Ako zelimo u klasi Izvedena ostaviti moguænost usporedbe sa cijelim brojevima te dodati jos usporedbu sa znakovnim nizovima, potrebno je ponoviti
definiciju operatora operator==(int) i u izvedenoj klasi
	class Izvedena : public Osnovna {
		// ...
	public:
		int operator==(char *niz);
		int operator==(int i) {
			return Osnovna::operator==(i);
		}
	};

Svaka izvedena klasa mora definirati svoj operator pridruzivanja(operator=). Jasna je i svrha tog pravila: operator pridruzivanja mora
inicijalizirati cijeli objekt, a ne samo njegov dio.
Pravilo koje se takoder vrlo cesto zaboravlja jest da se operator pridruzivanja ne nasljeduje.

	class Osnovna {
	public:
		// ...
		Osnovna& operator=(int a);
	};
	class Izvedena : public Osnovna {
	public:
		Izvedena();
		// ...
	};
	Izvedena izv;
	izv = 2; // pogreška prilikom prevođenja
Kako se operator pridruzivanja ne nasljeduje, klasa Izvedena nece imati operator pridruzivanja te ce se primjenjivati podrazumijevani operator
koji ce provesti kopiranje objekata jedan u drugi, bit po bit. No da bi se to moglo provesti, objekti moraju biti istog tipa. Prevoditelj ce
zbog toga pokusati konvertirati cijeli broj 2 u objekt klase Izvedena te ce pronaæi konstruktor s jednim parametrom koji ce obaviti konverziju.
Takav konstruktor ne postoji te ce se prijaviti pogreska.


neka c++ brlja
Svaki objekt izvedene klase sadrzava po jedan podobjekt svake osnovne klase. Zbog toga je pretvorba izvedene klase u osnovnu sigurna.
Obrnuto ne vrijedi.

	class Atom {
	private:
		Atom *pokSljedeci, *pokPrethodni;
	public:
		// funkcijski clanovi nisu bitni
	};
	class Vektor {
	private:
		float ax, ay;
	public:
		// funkcijski clanovi nisu bitni
	};
	class LVektor : public Atom, public Vektor {
	public:
		int redBroj;
		// funkcijski clanovi nisu bitni
	};
	
	pokazivac na LVektor --->|pokSljedeci  |  dio od klase Atom
	                         |pokPrerthodni|
							 |-------------|
	pokazivac na Vektor ---> |ax           |  dio od klase Vektor
							 |ay           |
							 |-------------|
							 |redBroj      |  dio od klase LVektor

Pokazivac na LVektor pokazivat ce na pocetak objekta. Prilikom pretvorbe u recimo pokazivac na Vektor, bit ce ga potrebno uvecati tako da pokazuje
na pocetak podobjekta Vektor.

>>>>>
Ugnjezdjeni tipovi i nasljedivanje
	class SkupNizova {
	protected:
	
		class Elem {
			Elem(char *niz);
			// ...
		};
		// ...
		
	};
Clanovi ugnijezdene klase se mogu definirati i izvan okolne klase. Tada se podrucja jednostavno nadovezuju operatorom :: po sljedecem principu:
	SkupNizova::Elem::Elem(char *niz) {
		// ...
	}
	
Takodjer, ugnijezdena klasa moze posluziti kao objekt nasljedivanja, s time da u tom slucaju ona mora biti javno dostupna:
	class SkupNizova {
	public:
		class Elem {
			Elem(char *niz);
		};
	};
	
	class NaslijediOd : public SkupNizova::Elem {
		// ...
	};

>>>>>
Klase kao argumenti funkcija

Ako postoje dvije funkcije od kojih u parametrima svaka ima po jednu neposrednu javnu osnovnu klasu, poziv funkcije se smatra automatski nejasnim
te se javlja pogreska prilikom prevodenja. Programer tada mora pomocu eksplicitne dodjele tipa odrediti koja se varijanta funkcije poziva:

	class LVektor:public Atom, public Vektor{
	...}
	
	void Obradi(Atom &obj);
	void Obradi(Vektor &obj);
	LVektor lv;

	// programer odreduje poziv funkcije Obradi(Vektor&) pomocu eksplicitne dodjele tipa
	Obradi((Vektor&)lv);

Ako postoji vise osnovnih klasa, pri cemu je samo jedna bliza klasi navedenog objekta, provodi se pretvorba u taj tip te se poziva odgovarajuca
funkcija:
	class A { };
	class B : public A { };
	class C : public B { };
	void funkcija(A &obj);
	void funkcija(B &obj);
	...
	C objc;
	// OK: poziva se funkcija(B &) jer je klasa B bliza klasi C nego klasa A
	funkcija(objc);

Mogli bismo napraviti funkcije Korijen1() i Korijen2() koje izracunavaju prvu i drugu vrijednost korijena iz kompleksnog broja te bismo ih mogli
koristiti i za obicne realne brojeve. Konverziju realnog broja u kompleksni mozemo obaviti konstruktorom:
	class Kompleksni {
	private:
		double cx, cy;
	public:
		Kompleksni(double a = 0, double b = 0): cx(a), cy(b) {}
		// ...
	};

	Kompleksni Korijen1(const Kompleksni &kompl) {
		// ...
	}
	
	//sam poziv funkcije s realnim brojem
	Kompleksni kor = Korijen1(3.9);


>>>>>
Segmentation fault
access to released objects

	Temp* someF(){
		Temp temp;
		.
		.
		return &temp;
	}
	or
	char *p = NULL;
	{
		char c;
		p = &c;
	}
If temp is returned as a pointer(*temp), the temp object will be destroyed at the
end of this method, and the caller will end up wit the poniter to object that
doesn't exist any more. this causes Segmentation fault.
solution is to create temp object with help of new Temp(), this object is stored in heap memory
and must be destroyed manually.
Same is valid for *p

>>>>>
slicno funkcijama, ako se ne namjerava pristupati vrijednosti parametra unutar bloka, dovoljno je samo navesti tip parametra,
a naziv se moze izostaviti.

>>>>>
try/catch

*****
jako vazno
Unistavaju se svi lokalni i privremeni objekti koji su definirani u bloku u kojem je doslo do iznimke. (ali samo u tom bloku)
*****

	try {
		// ...
	}
	catch (void *pok) {
		// sve pokazivačke iznimke će završiti ovdje
	}
	catch (char *pok) {
		// ovaj blok hvatanja nikada se neće dohvatiti, pa čak
		// ako se i baci objekt tipa char *
	}
	
Ponekad je potrebno napisati blok hvatanja koji ce preuzimati sve iznimke. To se moze uciniti tako da se kao parametar catch kljucnoj
rijeci stavi znak ... , slicno kao i prilikom deklaracije funkcije s neodredjenim parametrima. Kako nije dano niti ime niti tip parametru,
nije moguce pristupiti vrijednosti objekta koji je bacen.
	try {
		// ...
	}
	catch (...) {
		// ovdje će završiti sve iznimke
	}

Obrada iznimke se cesto mora obaviti u nekoliko koraka. Na primjer, do iznimke je doslo u funkciji koja je pozvana kroz cetiri prethodne
funkcije. U tom slucaju svaka funkcija mora uhvatiti iznimku, osloboditi memoriju i proslijediti iznimku nadredenoj funkciji kako bi ona
ispravno oslobodila svoje resurse. Iako je moguce iznimku proslijediti nadredenom bloku tako da se ponovo baci iznimka istog tipa,
jednostavnije je navesti kljucnu rijec "throw" bez parametra.
Dinamicka memorija se ne oslobada automatski nakon bacanja iznimke. To znaci da ce memorija zauzeta u bloku pokusaja ostati u memoriji
ako ju ne obrisemo u bloku hvatanja.
	void Problematicna() {
		throw 10;
	}
	void Func1() {
		char *mem = new char[100];
		try {
			Problematicna();
		}
		catch (...) {
			delete [] mem; // čišćenje zauzetih resursa
			throw; // prosljeđivanje iznimke
		}
		delete [] mem;
	}
	void Func2() {
		int *pok = new int[50];
		try {
			Func1();
		}
		catch (int) {
			delete [] pok;
			throw;
		}
		delete [] pok;
	}

Potrebno je biti oprezan i s alokacijama memorije pokazivacima koji su deklarirani unutar bloka pokusaja. Ta situacija je losa jer blok
hvatanja uopce nema prilike osloboditi zauzetu memoriju. Kada funkcija Problematicna() podigne iznimku, automatski æe se unistiti lokalni
pokazivac mem, a memorija nece biti oslobodena, niti ce se moci osloboditi u bloku hvatanja, jer nemamo vise pokazivac.
	try {
		char *mem = new char[100];
		Problematicna();
	}
	catch (...) {
		throw; // prosljeđivanje iznimke
	}

potrebno je obratiti paznju na razliku izmedu objekta kao parametra i reference na objekt kao parametra. Kada je kao parametar bloku
hvatanja navedena referenca, blok hvatanja moze promijeniti proslijedeni mu objekt. Ako on dalje proslijedi objekt, promjena ce biti
proslijedena narednim blokovima hvatanja.
U prvom slucaju kada je parametar u bloku hvatanja definiran kao referenca na objekt klase, to znaci da ce blok hvatanja baratati zapravo
s bacenim objektom, a ne s njegovom kopijom.
	void Func1() {
		try {
			// ... nekakva obrada
			throw Izn(10);
			// ostatak koda ...
		}
		catch (Izn& iznim) {
			// sljedeća naredba će ispisati 10
			cout << "U Func1: " << iznim.izn << endl;
			iznim.izn = 20;
			throw;
		}
	}
	void Func2() {
		try {
			Func1();
		}
		catch (Izn iznim) {
			// sljedeća naredba će ispisati 20
			cout << "U Func2: " << iznim.izn << endl;
			iznim.izn = 30;
			throw;
		}
	}
	void Func3() {
		try {
			Func2();
		}
		catch (Izn iznim) {
			// sljedeća naredba će ispisati opet 20
			cout << "U Func3: " << iznim.izn << endl;
		}
	}
Deklaracija objekta kao parametra moze rezultirati sporijom obradom iznimke (zbog toga sto je potrebno kopiranje i unistavanje objekta).
Zbog toga se cesto kao parametar navodi referenca na objekt, iako se ne namjerava mijenjati sama vrijednost objekta.

Lista mogucih iznimaka navodi se iza liste parametara funkcije tako da se navede kljucna rijec throw iza koje se u zagradama popisu svi
tipovi iznimaka koje funkcija moze baciti
	void Func1() throw(int, const char*, NizoveIznimke) { //moze izbaciti samo ova dva exceptiona
		// definicija funkcije
	}
	
	void Func2() throw() { // ne moze izbaciti bilo koji exception
		// funkcija koja ne baca nikakvu iznimku
	}
Vazno je uociti da lista mogucih iznimaka ne definira iznimke koje se smiju pojaviti unutar funkcije, nego iznimke koje mogu biti
proslijedene iz funkcije.

U slucaju da prilikom izvodenja konstruktora dode do pogreske, konstruktor ce baciti iznimku koja ce opisati pogresku.

>>>>>
Operator typeid

"typeid" se primjenjuje tako da se u zagradama navede >>>izraz<<< koji nakon izracunavanja ima vrijednost pokazivaca, objekta ili reference
na objekt neke klase. Kao rezultat operator ce dati informaciju o stvarnom tipu objekta tako sto ce vratiti referencu na konstantan objekt
klase type_info.
Takoder, moguce je operator primijeniti i na sam identifikator tipa, te se tada vraca objekt koji opisuje navedeni tip.
Naziv klase se moze dobiti pomocu poziva funkcijskog clana name().
	if (typeid(niz[i]) == typeid(Linija))
		niz[i]->Crtaj();
	
	cout << typeid(*go).name() << endl;
	
>>>>>
Static and dyanmic cast, const cast

	Linija *pokLinija = new LinijaSaStrelicama;	// upcast, static cast
	
	Linija *pokLinija = new Linija;
	LinijaSaStrelicama *lss = (LinijaSaStrelicama *)pokLinija; // downcast, can cause trouble

Moguce je prvo provjeriti koji je to tip na koji pokazivac pokLinija pokazuje, a zatim obaviti pretvorbu ako je ona dozvoljena.
U suprotnom, pretvorba se nece obaviti. Tu operaciju uvodi novi operator dynamic_cast.
"izr" predstavlja izraz ciju je vrijednost potrebno pretvoriti, a T predstavlja zeljeni tip. Kaze se da je pretvorba dinamicka zato
jer se ne obavlja prilikom prevodenja, nego prilikom izvodenja programa.
	dynamic_cast<T>(izr)
Ovaj operator ce obaviti i obicnu pretvorbu u osnovnu klasu
postupak isti bez obzira radi li se o pokazivacu ili referenci na objekt.

Nul-pokazivac ce se pretvoriti u samoga sebe.

Ako pretvorba nije moguca, ako se radi o pretvorbi pokazivaca, rezultat konverzije ce biti nul-pokazivac.
Ako se pak radi o konverziji referenci, bit će podignuta iznimka tipa bad_cast.
	Linija *pokLinija = new LinijaSaStrelicama;
	LinijaSaStrelicama *lss =
		dynamic_cast<LinijaSaStrelicama *>(pokLinija);
	if (lss) {
	// ...
	
	Linija &ln = *new Linija;
	try {
		dynamic_cast<LinijaSaStrelicama &>(ln).tipStrelice = 10;
	}
	catch (bad_cast) {
		cerr << "Loša pretvorba." << endl;
	}
}

ponekad se moze ukazati potreba da se privremeno konstantnost objekta ukloni, tome sluzi const_cast !?!?!?!
	const_cast<T>(izr)
	
	static_cast<T>(izr)
	reinterpret_cast<T>(izr)
Tip T oznacava ciljni tip dodjele te mora biti pokazivac, referenca, aritmeticki tip ili pobrojenje. Za vecinu tipova gornji operatori ce
dati isti rezultat kao i obican operator dodjele tipa (T)izr
Osnovna razlika je, tip T kod operatora static_cast mora u potpunosti biti poznat prilikom prevodenja, klasa u koju se pretvara mora biti
u cijelosti definirana (a ne samo deklarirana unaprijed)
	class Osnovna1 {
	public:
		int osn1;
	};
	class Osnovna2 {
	public:
		int osn2;
	};
	class Izvedena : public Osnovna1, public Osnovna2 {
	public:
		int izv;
	};
	int main() {
		Izvedena i;
		i.osn1 = i.osn2 = i.izv = 0;
		Osnovna2 *pok = static_cast<Osnovna2 *>(&i);
		pok->osn2 = 30;
		cout << i.osn1 << endl << i.osn2 << endl;
		return 0;
	}
Pokazivac &i pokazuje na prvu memorijsku lokaciju zauzetu objektom. Prilikom pretvorbe u pokazivac na klasu Osnovna2 vrijednost pokazivaca
se mora podesiti tako da on pokazuje na pocetak podobjekta Osnovna2. To je moguce zato sto operator dodjele tipa tretira klase kao
kompletne tipove
	int main() {
		Izvedena i;
		i.osn1 = i.osn2 = i.izv = 0;
		Osnovna2 *pok = reinterpret_cast<Osnovna2 *>(&i);
		pok->osn2 = 30;
		cout << i.osn1 << endl << i.osn2 << endl;
		return 0;
	}
Prilikom pretvorbe operator nece provesti nikakvu promjenu vrijednosti pokazivaca. On ce jednostavno interpretirati njegovu vrijednost
na novi nacin -  kao pokazivac na objekt Osnovna2. Pristup clanu osn2 preko pokazivaca pok rezultirat ce promjenom vrijednosti clana osn1
(ovo kao necemu slizi u C++)

>>>>>
Pretprocesor
Znak # koji oznacava pocetak pretprocesorske naredbe mora biti prvi znak u retku iza eventualnih praznina. Naredba se proteze do kraja retka
(tj. do znaka za novi redak), ali se moze nastaviti i u sljedecem retku, ako se redak zakljuci znakom \.

#include "mojeKlase.h" // iz tekućeg imenika
#include <iostream.h> // iz standardnog imenika
<datoteka>, datoteka se trazi u standardnom imeniku za datoteke zaglavlja,
"datoteka", datoteka se prvo trazi u tekucem (radnom) imeniku, a ako se ne pronade tamo, datoteka se trazi u standardnim imenicima
za datoteke zaglavlja.
Another common question involves how to include header files from other directories.
One (bad) way to do this is to include a relative path to the header file you want to include as part of the #include line.
	#include "headers/myHeader.h"
	#include "../moreHeaders/myOtherHeader.h"
If you ever update your directory structure, your code won’t work anymore.
A better method is to tell your compiler or IDE that you have a bunch of header files in some other location, so that it will look there
when it can’t find them in the current directory.
Using g++, you can use the -I option to specify an alternate include directory.
	g++ -o main -I/source/includes main.cpp
Best practice
Order your #includes as follows: your own user-defined headers first, then 3rd party library headers, then standard library headers,
with the headers in each section sorted alphabetically.

Pretprocesorskom naredbom #define definira se vrijednost simbola, tzv macro name.
Iako nije nuzno, uobicajena je programerska praksa da se, zbog lakse uocljivosti u izvornom kodu, makro imena pisu velikim slovima.
	a = NEKAJ; // nadomjestit će
	char *b = "NEKAJ"; // neće nadomjestiti, sadrzaj znakovnog niza ostati nepromijenjen, jer pretprocesor ne pretrazuje sadrzaje
							znakovnih nizova.
Vrijednost makro imena moze se promijeniti novom naredbom #define.
Jednom definirano makro ime ostaje definirano do kraja tekuce datoteke ili do naredbe #undef kojom se on ponistava.

Pomoæu naredbe #define mogu se definirati i makro funkcije. Makro funkcija je simbol stvoren pomocu #define naredbe, koji moze prihvacati
argumente poput funkcija pisanih u jeziku C++.
	#define imeMakroFun( lista_argumenata ) ( tijelo_funkcije )
Pretprocesor ce simbolicki poziv makro funkcije u izvornom kodu nadomjestiti tijelom makro funkcije s umetnutim stvarnim argumentima.

	#define PROVJERA(varijabla) \
			cout << #varijabla " = " << varijabla << endl
Operator # ispred simbolickog imena pretvorit ce ga u znakovni niz.

#if, #ifdef, #ifndef, #elif, #else, #endif

>>>>>
Povezivanje

Sto valja staviti u datoteke zaglavlja? Buduci da su objekti i funkcije s vanjskim povezivanjem vidljivi u svim modulima, ako zelimo
omoguciti pravilno prevodenje pojedinih modula, ocito je neophodno navesti deklaracije svih objekata i funkcija koji ce biti koristeni
izvan modula u kojem su definirani. Kako cesto ne mozemo unaprijed znati hoce li neka funkcija ili objekt zatrebati u nekom drugom modulu,
nije na odmet u datotekama zaglavlja navesti deklaracije svih (nestatickih) globalnih funkcija i objekata. Osim toga, navodenjem svih
deklaracija u datoteci zaglavlja kod ce biti pregledniji, jer ce sve deklaracije (osim za staticke objekte i funkcije) biti
na jednom mjestu.
Vjerujemo da je svakom jasno da u datoteke zaglavlja takoder treba staviti definicije objekata i funkcija s unutarnjim povezivanjem
(inline funkcije i simbolicke konstante), zelimo li da oni budu dohvatljivi i iz drugih datoteka. Isto tako, u datotekama zaglavlja treba
navesti definicije tipova (deklaracije klasa) i predloske.

Sto navesti u datotekama zaglavlja:
	Pretprocesorske naredbe #include
	Definicije tipova (deklaracije klasa i struktura):
		"inline" funkcijski clanovi se moraju navesti unutar deklaracije klase.
	Deklaracija i definicije predlosaka (u nekim slucajevima)
		- starije verzije C++ - smjestiti definiciju predloska u datoteku zaglavlja. Tako bi u svakoj datoteci koja ukljucuje to zaglavlje,
			predlosci bili automatski dostupni, te bi se prilikom prevođenja zeljeni predlosci instancirali.
			Ako bi vise datoteka izvornog koda koristilo isti predlozak iz neke datoteke zaglavlja, na kraju bismo dobili objektni kod 
			koji bi sadrzavao nekoliko instanci iste funkcije. Ali blabla.....
		- samo deklarirati predlozak u datoteci zaglavlja, a posebnu datoteku u kojoj su definicije staviti prevoditelju na raspolaganje.
			te da se eksplicitno prisili prevoditelj da instancira predlozak za sve koristene varijante parametara. To se moze uciniti tako
			da se stvori neki globalni objekt ili da se pozove zeljena funkcija.
			I tu ima neki ali .....
		- posljednja verzija standarda jezika podrzava eksplicitnu instantaciju predlozaka, pa programer moze sam odrediti koje sve
			predloske treba generirati, tako da se za predloak za odredeni tip, u datoteku gdje je predlozak definiran ubaci se dodatna
			naredba za instantaciju.
			template class Kompleksni<double>;
			template class Kompleksni<int>;
			template ostream &operator <<(ostream &,Kompleksni<double>);
			template ostream &operator <<(ostream &,Kompleksni<int>);
			Medutim, pogodnije je instancu predloska za svaki poseban korisnicki tip smjestiti u zasebnu datoteku. i tu ima neka fora kako
			to napraviti......
		
	Deklaracije funkcija:
		extern void ReciMiReci.....
	Definicije inline funkcija:
		inline double kvadrat....
	Deklaracije globalnih podataka koji moraju biti dohvatljivi iz razlicitih modula:
		extern char *verzijaPrograma;
	Definicije konstanti koje moraju biti dohvatljive iz razlicitih modula:
		const float e = 2.718282
	Pobrojenja:
		enum neprijatelj { unutarnji, vanjski, VanOvan, Feral };
	Makro definicije i makro funkcije

Sto ne stavljati u datoteke zaglavlja:
Definicije funkcija
Definicije objekata
	int a; - u svakoj datoteci u koju ukljucimo datoteku zaglavlja dobiti cemo po jedan globalni simbol navedenog imena
>>>>>
Some examples

*****
class Tablica{
	private:
		int *elements;
	public:
		Tablica();
		void increase(int numElements);
	...
}

Tablica::Tablica(): elements(new int[10]){
}

void Tablica::increase(int newNum){
	int *newElements = new int[newNum];
	for (int i = 0; i < currNum; i++){
		newElements[i] = elements[i];
	}
	delete [] elements;
	elements = newElements;
}

*****
	#ifndef TOCKA_H
	#define TOCKA_H
	// deklaracija i definicije
	#endif
Pomocu ovakvog ispitivanja izbjegava se moguca visekratna deklaracija klase.
U gornjem programu deklaracija klase Tocka ukljucena je u modul poglavar.cpp. Istovremeno, klasa Tocka mora biti poznata deklaraciji
klase Pravac. Kako je deklaracija klase Pravac takoder ukljucena u modul poglavar.cpp, deklaracija klase Tocka pojaviti ce se dva puta.
Na ovo ce prevoditelj prijaviti kao pogresku.
	pragma once
valjda rjesava isti problem

*****
lukavo, lukavo nema sto:

Obratimo paznju na to kako su manipulatori realizirani.
Radi se, naime, o jednom lukavom triku: svi manipulatori bez parametra su realizirani kao funkcija koja kao parametar uzima referencu
na tok. Tako u datoteci zaglavlja iostream.h postoji deklaracija te funkcije koja ispisuje znak '\n'.
No kada se u ispisnoj listi navede samo "endl" bez zagrada, to je zapravo pokazivac na funkciju. Operator << je preopterecen tako da
prihvaca pokazivac na funkciju, te on u biti poziva funkciju navodeci tok kao parametar
	typedef ostream &(*Omanip)(ostream &);
	ostream &operator<<(ostream &os, Omanip f) {
		return f(os);
	}
Tip Omanip je pokazivac na funkciju koja kao parametar uzima referencu na ostream i vraca referencu na ostream. Izraz
	cout << endl;
se interpretira kao
	operator<<(cout, endl);
	
*****
neka c++ fora s operatorima

	class Paleta {
		// ...
		Boja &operator [](int indeks);
		// ...
	};
Sto smo dobili ovakvim rjesenjem? Vracanjem reference na objekt smo automatski omogucili da se operator [] nade s lijeve strane
znaka pridruzivanja. Time bi bilo omoguceno postavljanje boja u paletu po sljedecem principu:
	Paleta p;
	p[0] = Boja(127, 127, 127);
No takvo rjesenje ne mora uvijek odgovarati. Ono zapravo pretpostavlja tocno odredenu implementaciju koja ne mora uvijek biti ispravna.
Operator [] jednostavno vraca referencu na odredeni element niza iz Paleta-e. Gornje pridruzivanje se tada provodi tako da se pozove
operator = za klasu Boja. Klasa Paleta vise nema nikakvog nadzora nad pridruzivanjem svojim clanovima

*****
Ovo moze raditi samo u slucaju da u arrayu/vektoru na koji pokazuje p postoji vrijednost 0(ili sta vec koje se transformira u false u c++)
Inace 'for' uvijet za zaustavljanj petlje mozda nikad nece doci do 'false'
for (const U32* p = m_supportedProtocolRevList; *p; p++)
    {
        if (*p == rev)
        {
            return true;
        }
    }
